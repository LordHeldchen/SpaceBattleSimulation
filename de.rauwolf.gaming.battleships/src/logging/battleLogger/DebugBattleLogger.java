package logging.battleLogger;

import java.util.HashSet;
import java.util.Map;
import java.util.PriorityQueue;

import ships.Fleet;
import ships.Ship;

public class DebugBattleLogger implements BattleLogger {
    private int round = 0;

    private DebugBattleLogger() {}

    public static DebugBattleLogger getNewDebugBattleLogger() {
        return new DebugBattleLogger();
    }

    @Override
    public void showFormup(HashSet<Fleet> allFleets,
                           PriorityQueue<Ship> allShips,
                           Map<Integer, Fleet> enemiesOfEmpireX,
                           HashSet<Ship> participatingFighters) {
        System.out.println("Formup: ");
        for (Fleet fleet : allFleets) {
            System.out.println(fleet);
        }

        System.out.println("=== Additional Info ===");
        for (int empireID : enemiesOfEmpireX.keySet()) {
            System.out.println("Enemies of empire " + empireID + ": " + enemiesOfEmpireX.get(empireID).size());
        }
        System.out.println();
        System.out.println("Participating Fighters: " + participatingFighters.size());
        System.out.println("Size of AllShips: " + allShips.size());
    }

    @Override
    public void checkPayloadAfterAttack(Ship ship) {
        if (ship.hasPayloadRemaining()) {
            System.out.println();
        } else {
            System.out.println("No more payload: " + ship + "\n");
        }
    }

    @Override
    public void shipDestroyed(Ship target) {
        System.out.println("Ship destroyed: " + target);
    }

    @Override
    public void endOfBattle(HashSet<Fleet> allFleets) {
        System.out.println("End of battle! Ships remaining: ");
        for (Fleet fleet : allFleets) {
            System.out.println(fleet);
            for (Ship ship : fleet) {
                ship.endBattle();
            }
        }
    }

    @Override
    public void endOfSingleAttack(Ship attacker) {
        if (!attacker.hasPayloadRemaining()) {
            System.out.println(attacker.getName() + " has to reload as next action.");
        }
    }

    @Override
    public void beginSingleAttack(final Ship attacker, final Ship target) {
        System.out.println("Round " + round + ": " + attacker + " goes against " + target);
    }

    @Override
    public void nextRound() {
        round++;
    }

    @Override
    public void shipReacts(Ship ship) {
        System.out.println(ship + " reacts successfully!");
    }

    @Override
    public void evades(Ship ship, boolean doesEvade) {
        if (doesEvade) {
            System.out.println(ship + " evades all damage");
        }
    }

    @Override
    public void armorDeflectsAllDamage(Ship ship) {
        System.out.println("Armor of " + ship + " deflects all Damage!");
    }

    @Override
    public void takesArmorDamage(Ship ship, int damage) {
        System.out.println("Armor of " + ship + " takes " + damage + " points of damage");
    }

    @Override
    public void shieldBreaks(Ship ship) {
        System.out.println("Shield of " + ship + " breaks!");
    }

    @Override
    public void takesShieldDamage(Ship ship, int amount) {
        System.out.println("Shield of " + ship + " deflects " + amount + " points of damage");
    }

    @Override
    public void regeneratesShield(Ship ship, int regeneration, int shieldNow) {
        System.out.println("Shields of " + ship + " regenerated by " + regeneration + " to " + shieldNow);
    }

    @Override
    public void preysOnPreferredTargetType(Ship ship) {
        System.out.println("Preys on preferred Target type!");
    }

    @Override
    public void hasResupplied(Ship ship, Ship mothership) {
        System.out.println(ship + ": Resupplied at " + mothership);
    }
}

package logging.battleLogger;

import java.util.HashSet;
import java.util.Map;
import java.util.PriorityQueue;

import battle.CombatActor;
import battle.CombatTarget;
import battle.ShieldInstance;
import battle.ShipInstance;
import ships.Fleet;

public class DebugBattleLogger implements BattleLogger {
    private int round = 0;

    private DebugBattleLogger() {}

    public static DebugBattleLogger getNewDebugBattleLogger() {
        return new DebugBattleLogger();
    }

    @Override
    public void showFormup(HashSet<Fleet> allFleets,
                           HashSet<ShipInstance> allShips,
                           PriorityQueue<CombatActor> combatActors, 
                           Map<Integer, Fleet> enemiesOfEmpireX,
                           HashSet<ShipInstance> participatingFighters) {
        System.out.println("Formup: ");
        for (Fleet fleet : allFleets) {
            System.out.println(fleet);
        }

        System.out.println("=== Additional Info ===");
        for (int empireID : enemiesOfEmpireX.keySet()) {
            System.out.println("Enemies of empire " + empireID + ": " + enemiesOfEmpireX.get(empireID).size());
        }
        System.out.println();
        System.out.println("Participating Fighters: " + participatingFighters.size());
        System.out.println("Amount of participating Ships: " + allShips.size());
        System.out.println("Amount of active actors: " + combatActors.size());
    }

    @Override
    public void shipDestroyed(CombatTarget target) {
        System.out.println("Target destroyed: " + target);
    }

    @Override
    public void endOfBattle(HashSet<Fleet> allFleets) {
        System.out.println("End of battle! Ships remaining: ");
        for (Fleet fleet : allFleets) {
            System.out.println(fleet);
        }
    }

    @Override
    public void endOfSingleAttack(ShipInstance attacker) {}

    @Override
    public void beginSingleAttack(final CombatActor attacker, final CombatTarget target) {
        System.out.println("Round " + round + ": " + attacker + " goes against " + target);
    }

    @Override
    public void nextRound() {
        round++;
    }

    @Override
    public void shipReacts(CombatTarget target) {
        System.out.println(target + " reacts successfully!");
    }

    @Override
    public void evades(ShipInstance ship, boolean doesEvade) {
        if (doesEvade) {
            System.out.println(ship + " evades all damage");
        }
    }

    @Override
    public void armorDeflectsAllDamage(ShipInstance ship) {
        System.out.println("Armor of " + ship + " deflects all Damage!");
    }

    @Override
    public void takesHullDamage(ShipInstance ship, int damage, HullDamageType damageType) {
        System.out.println("Armor of " + ship + " takes " + damage + " points of " + damageType + " damage.");
    }

    @Override
    public void shieldBreaks(ShieldInstance shield) {
        System.out.println("Shield of " + shield.getOwner() + " breaks!");
    }

    @Override
    public void takesShieldDamage(ShieldInstance shield, int amount) {
        System.out.println("Shield of " + shield.getOwner() + " deflects " + amount + " points of damage");
    }

    @Override
    public void regeneratesShield(ShieldInstance shield, int regeneration, int shieldNow) {
        System.out.println("Shields of " + shield.getOwner() + " regenerated by " + regeneration + " to " + shieldNow);
    }

    @Override
    public void preysOnPreferredTargetType(CombatActor ship) {
        System.out.println("Preys on preferred Target type!");
    }

    @Override
    public void hasResupplied(ShipInstance ship, ShipInstance mothership) {
        System.out.println(ship + ": Resupplied at " + mothership);
    }
}
